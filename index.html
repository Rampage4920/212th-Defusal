<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>212th Bomb Defusal Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.5" />
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0b0b; color:#eee; }
    .container { max-width: 980px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 6px; }
    .hint { color:#aaa; margin: 0 0 14px; }

    .controls {
      display:grid;
      grid-template-columns: repeat(4, minmax(160px,1fr)) auto;
      gap:10px;
      padding:12px;
      background:#161616;
      border:1px solid #262626;
      border-radius:12px;
      align-items:end;
    }
    .slot { display:flex; flex-direction:column; gap:6px; }
    select { padding:8px; border-radius:8px; border:1px solid #333; background:#1f1f1f; color:#eee; }
    button { padding:10px 14px; border-radius:10px; background:#222; border:1px solid #333; color:#eee; cursor:pointer; }

    .metaRow { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top:10px; color:#aaa; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #333; background:#1f1f1f; border-radius:999px; }

    .results { margin-top:14px; display:grid; gap:8px; }
    .listHead, .card {
      display:grid;
      grid-template-columns: minmax(0, 1fr) max-content; /* left grows, right hugs */
      align-items:center;
      gap:2px; /* tighter gap between combo and defusal */
      padding:8px 12px;
      border-radius:10px;
    }
    .listHead { color:#bbb; }
    .card { background:#161616; border:1px solid #262626; }
/* Slow green pulse for the single remaining result card only */
@keyframes cardPulse {
  0%   { background-color: #161616; }  /* your card base */
  50%  { background-color: #1e3a1e; }  /* subtle green tint */
  100% { background-color: #161616; }
}
.card.pulse {
  animation: cardPulse 2.5s ease-in-out infinite;
}
    .combo {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      display:inline-flex;
      flex-wrap:nowrap;   /* keep whole combo on one line */
      gap:4px;
      white-space:nowrap;
    }
    .chip {
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #333;
      background:#1f1f1f;
    }

    .out {
      display:inline-flex; /* coloured defusal chips */
      flex-wrap:nowrap;
      gap:4px;
      white-space:nowrap;
    }

    .panel {
      margin-top:14px;
      padding:10px 12px;
      background:#101010;
      border:1px solid #2a2a2a;
      border-radius:12px;
    }
    .panel strong { margin-right:6px; }
/* Dynamic zoom for results */
:root { --results-zoom: 1; }
.resultsZoom {
  transform: scale(var(--results-zoom));
  transform-origin: top left;
  width: calc(100% / var(--results-zoom)); /* keep layout width the same */
}
  </style>

  <!-- BEGIN COMBO DATA (one per line, exactly four colours, left→right) -->
  <script id="combos" type="text/plain">
# Replace with your combos in order (left → right)
Red, Purple, Black, Yellow
Red, Purple, Yellow, Grey
Orange, Pink, Green, Grey
Yellow, Orange, Blue, Yellow
Green, Orange, Black, Yellow
Green, Yellow, Orange, Blue
Green, Yellow, Red, White
Green, Yellow, Yellow, Black
Blue, Green, Yellow, Red
Blue, Green, Purple, Pink
Blue, White, Red, Black
Blue, Yellow, Grey, Red
Purple, Red, Pink, White
Brown, Orange, Yellow, White
Grey, White, Blue, Black
White, Blue, Red, Black
Black, Brown, White, Green
  </script>
  <!-- END COMBO DATA -->

  <!-- BEGIN OUTPUT DATA (one per line; line N maps to combo line N) -->
  <script id="outputs" type="text/plain">
Purple, Red
Purple, Yellow, Red
Pink, Grey
Orange, Blue
Green, Black, Yellow
Green, Yellow
Red
Left Yellow, Black
Red, Blue
Green, Blue
Blue
Yellow, Blue
Red, Pink
Orange, White
White, Black
Blue
Brown, Black
  </script>
  <!-- END OUTPUT DATA -->
</head>
<body>
  <main class="container">
    <h1>212th Bomb Defusal Tool</h1>
    <p class="hint">Read the Wires from Left to Right Horizontally</p>

    <section class="controls">
      <div class="slot"><label>Wire 1</label><select id="w1"></select></div>
      <div class="slot"><label>Wire 2</label><select id="w2"></select></div>
      <div class="slot"><label>Wire 3</label><select id="w3"></select></div>
      <div class="slot"><label>Wire 4</label><select id="w4"></select></div>
      <button id="clear" style="background:#ff0000;border-color:#ff0000;color:#fff;font-weight:700">Clear</button>
    </section>

    <div class="metaRow">
      <div id="count" class="badge">0 matches</div>
      <div id="status" class="badge"></div>
    </div>

    <div class="results resultsZoom" id="resultsZoom">
      <div class="listHead">
        <div>Wire Combo</div>
        <div>Defusal</div>
      </div>
      <div id="rows"></div>
    </div>

    <div id="exactPanel" class="panel" style="display:none;">
      <div><strong>Exact match:</strong> <span id="exactCombo"></span></div>
      <div><strong>Defusal:</strong> <span id="exactOutput" class="out"></span></div>
    </div>
  </main>

  <script>
    // Base palette; extended by any colours discovered in the combos
    const BASE_PALETTE = ["", "Red","Blue","Yellow","Black","Orange","White","Green","Purple","Pink","Grey","Brown","Left Yellow"];
    const selects = ["w1","w2","w3","w4"].map(id => document.getElementById(id));
    const clearBtn = document.getElementById("clear");
    const rowsWrap = document.getElementById("rows");
    const countEl = document.getElementById("count");
    const statusEl = document.getElementById("status");
    const exactPanel = document.getElementById("exactPanel");
    const exactCombo = document.getElementById("exactCombo");
    const exactOutput = document.getElementById("exactOutput");
    const resultsZoomEl = document.getElementById("resultsZoom");


    const norm = s => (s||"").trim().toLowerCase();
    const titleCase = s => s.replace(/\w\S*/g, t => t[0].toUpperCase() + t.slice(1).toLowerCase());

    // Wire colour mapping
    const COLOR_MAP = {
      "red":"#ff4b4b",
      "blue":"#3ea0ff",
      "yellow":"#ffd84a",
      "black":"#d0d0d0",
      "orange":"#ffa14a",
      "white":"#ffffff",
      "green":"#50d074",
      "purple":"#c58cff",
      "pink":"#ff94c2",
      "grey":"#9a9a9a",
      "gray":"#9a9a9a",
      "brown":"#b47a4d",
      "left yellow":"#ffd84a"
    };

    let combos = [];   // [[c1,c2,c3,c4], ...]
    let outputs = [];  // ["CSV string", ...]
    let palette = [...BASE_PALETTE];

    function parseCombos(text) {
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'))
        .map(l => l.split(',').map(x => titleCase(x.trim())))
        .filter(parts => parts.length === 4);
    }

    function parseOutputs(text) {
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'));
    }

    function buildPaletteFromCombos(list) {
      const set = new Set(BASE_PALETTE);
      for (const row of list) for (const c of row) set.add(c);
      const arr = Array.from(set).filter(v => v !== "");
      arr.sort((a,b) => a.localeCompare(b));
      return ["", ...arr];
    }

    function populateSelect(sel, values) {
      sel.innerHTML = "";
      for (const v of values) {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v || "— any —";
        sel.appendChild(opt);
      }
    }

    function getSelections() { return selects.map(s => s.value); }

    function filteredIndexes(selections) {
      // Return indexes of combos matching current selections (wildcards allowed)
      const idxs = [];
      for (let i = 0; i < combos.length; i++) {
        const row = combos[i];
        const ok = selections.every((v, idx) => !v || norm(v) === norm(row[idx]));
        if (ok) idxs.push(i);
      }
      return idxs;
    }

    function allowedByIndex(selections, index) {
      const otherSel = selections.map((v, i) => (i === index ? "" : v));
      const idxs = filteredIndexes(otherSel);
      const set = new Set(idxs.map(i => combos[i][index]));
      return Array.from(set);
    }

    function refreshOptions() {
      const sel = getSelections();
      for (let i = 0; i < selects.length; i++) {
        const allowed = new Set(allowedByIndex(sel, i));
        const current = selects[i].value;
        const ordered = palette.filter(v => v === "" || allowed.has(v));
        populateSelect(selects[i], ordered);
        if (current && allowed.has(current)) selects[i].value = current; else selects[i].value = "";
      }
    }

    function colorSpan(text) {
      const key = norm(text);
      const color = COLOR_MAP[key] || "#ddd";
      const span = document.createElement("span");
      span.className = "chip";
      span.style.color = color;
      span.textContent = text;
      return span;
    }

    function chipsFromCsv(text) {
      const out = [];
      const raw = (text || "").trim();
      if (!raw) return out;
      for (const part of raw.split(",")) {
        const t = part.trim();
        if (!t) continue;
        out.push(colorSpan(t));
      }
      return out;
    }

    function render() {
      const sel = getSelections();
      const idxs = filteredIndexes(sel);

      // Deduplicate results by normalized 4-wire combo
      const seen = new Set();
      const unique = [];
      for (const i of idxs) {
        const key = combos[i].map(v => norm(v)).join("|");
        if (!seen.has(key)) {
          seen.add(key);
          unique.push(i);
        }
      }
// --- Dynamic zoom based on how many matches remain ---
const pivot = 12;        // start zooming when <= 12 matches
const maxZoom = 1.4;     // 140% when only one left
let z = 1;
if (unique.length <= pivot) {
  z = 1 + (pivot - unique.length) * ((maxZoom - 1) / pivot);
}
z = Math.min(maxZoom, Math.max(1, z));
document.documentElement.style.setProperty('--results-zoom', z.toFixed(2));

// --- Background pulse when exactly one match remains ---
      countEl.textContent = `${unique.length} match${unique.length === 1 ? "" : "es"}`;
      rowsWrap.innerHTML = "";
      exactPanel.style.display = "none";

      // Data alignment status
      if (outputs.length === combos.length) {
        statusEl.className = "badge";
        statusEl.style.color = "#9ff3aa";
        statusEl.textContent = "data OK";
      } else {
        statusEl.className = "badge";
        statusEl.style.color = "#ffd58a";
        statusEl.textContent = `mismatch: ${outputs.length} outputs for ${combos.length} combos`;
      }

      for (const i of unique) {
        const card = document.createElement("div");
        card.className = "card";
         if (unique.length === 1) {
    card.classList.add("pulse");   // <-- make the only card pulse
  }

        const left = document.createElement("div");
        left.className = "combo";
        for (const token of combos[i]) left.appendChild(colorSpan(token));

        const right = document.createElement("div");
        right.className = "out";
        const chips = chipsFromCsv(outputs[i] ?? "");
        if (chips.length === 0) {
          right.textContent = "(no output)";
        } else {
          for (const el of chips) right.appendChild(el);
        }

        card.appendChild(left);
        card.appendChild(right);
        rowsWrap.appendChild(card);
      }

      // Exact-match emphasis when all 4 are chosen
      const allChosen = sel.every(Boolean);
      if (allChosen) {
        let exactIdx = -1;
        for (const i of idxs) {
          const row = combos[i];
          if (row.every((v, k) => norm(v) === norm(sel[k]))) { exactIdx = i; break; }
        }
        if (exactIdx !== -1) {
          exactCombo.innerHTML = "";
          for (const token of combos[exactIdx]) exactCombo.appendChild(colorSpan(token));
          exactOutput.innerHTML = "";
          const exactChips = chipsFromCsv(outputs[exactIdx] ?? "");
          if (exactChips.length === 0) {
            exactOutput.textContent = "(no output)";
          } else {
            for (const el of exactChips) exactOutput.appendChild(el);
          }
          exactPanel.style.display = "block";
        }
      }
    }

    function onChange() { refreshOptions(); render(); }
    function clearSelections() { for (const s of selects) s.value = ""; refreshOptions(); render(); }

    function loadEmbedded() {
      const comboText = document.getElementById("combos").textContent || "";
      const outputText = document.getElementById("outputs").textContent || "";
      combos = parseCombos(comboText);
      outputs = parseOutputs(outputText);
      palette = buildPaletteFromCombos(combos);
      for (const sel of selects) populateSelect(sel, palette);
      refreshOptions(); render();
    }

    // Init
    for (const sel of selects) populateSelect(sel, palette);
    for (const sel of selects) sel.addEventListener("change", onChange);
    clearBtn.addEventListener("click", (e) => { e.preventDefault(); clearSelections(); });
    loadEmbedded();
  </script>
</body>
</html>
